#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>


//fixed 256-element lookup table
unsigned char sbox[256] = {
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

//inverse of 256-element lookup table used for decryption
unsigned char sboxinv[256] = {
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

//lookup table for special matrix in multiplying Galois fields by 2
unsigned char mul2[] = {
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
	0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
	0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
	0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
	0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
	0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
	0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
	0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
	0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
};

//lookup table for special matrix in multiplying Galois fields by 3
unsigned char mul3[] = {
	0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
	0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
	0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
	0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
	0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
	0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
	0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
	0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
	0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
	0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
	0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
	0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
	0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
	0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
	0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
	0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
};

//lookup table for special matrix in multiplying Galois fields by 9
unsigned char mul9[] = {
	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
	0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
	0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
	0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
	0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
	0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
	0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
	0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
	0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
	0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
	0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
	0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
	0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
	0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
	0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,
};

//lookup table for special matrix in multiplying Galois fields by 11
unsigned char mulb[] = {
	0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
	0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
	0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
	0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
	0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
	0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
	0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
	0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
	0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
	0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
	0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
	0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
	0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
	0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
	0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
	0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,
};

//lookup table for special matrix in multiplying Galois fields by 13
unsigned char muld[] = {
	0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
	0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
	0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
	0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
	0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
	0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
	0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
	0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
	0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
	0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
	0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
	0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
	0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
	0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
	0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
	0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,
};

unsigned char mule[] = {
	0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
	0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
	0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
	0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
	0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
	0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
	0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
	0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
	0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
	0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
	0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
	0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
	0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
	0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
	0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
	0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,
};

unsigned char rcon[255] = {
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb,
};

/*performs subBytes function, using the value of each byte
* as an index to the sbox table, and then replacing the value in the state
* by the value at that index in the sbox table */
void subBytes(unsigned char* curstate) {
  for (int i = 0; i < 16; ++i) {
      //using the value of the current element in the state to get the index
      unsigned char sbox_index = curstate[i];
      //replace current element's value with sbox value at the found index
      curstate[i] = sbox[sbox_index];
  }
}

/* uses the sbox inverse lookup table to perform an inverse of subBytes,
* used for decryption */
void invSubBytes(unsigned char* curstate) {
  for (int i = 0; i < 16; ++i) {
    //using the value of the current element in the state to get the index for the inverse
    unsigned char sbox_inv_index = curstate[i];
    //replace current element's value with sbox inverse value at the found index
    curstate[i] = sboxinv[sbox_inv_index];
  }
}

/* shifts first row to the left by 0 bytes, second row by 1 byte,
* third row by 2 bytes, 4th row by 3 bytes, simply hardcoding this */
void shiftRows(unsigned char* curstate) {
    //the resulting array representing the state after shifting rows
    unsigned char result[16];

    /*shifts in the first column (first row shifts by 0 bytes,
    * second row shifts 1 byte to the left
    * third row shifts 2 bytes to the left
    * fourth row shifts 3 bytes to the left) */
    result[0] = curstate[0];
    result[1] = curstate[5];
    result[2] = curstate[10];
    result[3] = curstate[15];

    /*shifts in the second column (first row shifts by 0 bytes,
    * second row shifts 1 byte to the left
    * third row shifts 2 bytes to the left
    * fourth row shifts 3 bytes to the left) */
    result[4] = curstate[4];
    result[5] = curstate[9];
    result[6] = curstate[14];
    result[7] = curstate[3];

    /*shifts in the third column (first row shifts by 0 bytes,
    * second row shifts 1 byte to the left
    * third row shifts 2 bytes to the left
    * fourth row shifts 3 bytes to the left) */
    result[8] = curstate[8];
    result[9] = curstate[13];
    result[10] = curstate[2];
    result[11] = curstate[7];

    /*shifts in the fourth column (first row shifts by 0 bytes,
    * second row shifts 1 byte to the left
    * third row shifts 2 bytes to the left
    * fourth row shifts 3 bytes to the left) */
    result[12] = curstate[12];
    result[13] = curstate[1];
    result[14] = curstate[6];
    result[15] = curstate[11];

    //reassigning the correct values to the current state using the results from shiftRows
    for (int i = 0; i < 16; ++i) {
      curstate[i] = result[i];
    }
}

/* shifts first row to the right by 0 bytes, second row by 1 byte,
* third row by 2 bytes, 4th row by 3 bytes, simply hardcoding this */
void invShiftRows(unsigned char* curstate) {
    //the resulting array representing the state after shifting rows
    unsigned char result[16];

    /*shifts in the first column (first row shifts by 0 bytes,
    * second row shifts 1 byte to the right
    * third row shifts 2 bytes to the right
    * fourth row shifts 3 bytes to the right) */
    result[0] = curstate[0];
    result[1] = curstate[13];
    result[2] = curstate[10];
    result[3] = curstate[7];

    /*shifts in the second column (first row shifts by 0 bytes,
    * second row shifts 1 byte to the right
    * third row shifts 2 bytes to the right
    * fourth row shifts 3 bytes to the right) */
    result[4] = curstate[4];
    result[5] = curstate[1];
    result[6] = curstate[14];
    result[7] = curstate[11];

    /*shifts in the third column (first row shifts by 0 bytes,
    * second row shifts 1 byte to the right
    * third row shifts 2 bytes to the right
    * fourth row shifts 3 bytes to the right) */
    result[8] = curstate[8];
    result[9] = curstate[5];
    result[10] = curstate[2];
    result[11] = curstate[15];

    /*shifts in the fourth column (first row shifts by 0 bytes,
    * second row shifts 1 byte to the right
    * third row shifts 2 bytes to the right
    * fourth row shifts 3 bytes to the right) */
    result[12] = curstate[12];
    result[13] = curstate[9];
    result[14] = curstate[6];
    result[15] = curstate[3];

    //reassigning the correct values to the current state using the results from shiftRows
    for (int i = 0; i < 16; ++i) {
      curstate[i] = result[i];
    }
}

/* replacing each column by its value multiplied by a 4x4 matrix
* */
void mixColumns(unsigned char* curstate) {
  //stores the resulting multiplied matrix
  unsigned char result[16];
  /*hardcoding the matrix multiplication,
  * XOR bits is the equivalent the addition part of the dot products */
  result[0] = (unsigned char)(mul2[curstate[0]] ^ mul3[curstate[1]] ^ curstate[2] ^ curstate[3]);
  result[1] = (unsigned char)(curstate[0] ^ mul2[curstate[1]] ^ mul3[curstate[2]] ^ curstate[3]);
  result[2] = (unsigned char)(curstate[0] ^ curstate[1] ^ mul2[curstate[2]] ^ mul3[curstate[3]]);
  result[3] = (unsigned char)(mul3[curstate[0]] ^ curstate[1] ^ curstate[2] ^ mul2[curstate[3]]);

  result[4] = (unsigned char)(mul2[curstate[4]] ^ mul3[curstate[5]] ^ curstate[6] ^ curstate[7]);
  result[5] = (unsigned char)(curstate[4] ^ mul2[curstate[5]] ^ mul3[curstate[6]] ^ curstate[7]);
  result[6] = (unsigned char)(curstate[4] ^ curstate[5] ^ mul2[curstate[6]] ^ mul3[curstate[7]]);
  result[7] = (unsigned char)(mul3[curstate[4]] ^ curstate[5] ^ curstate[6] ^ mul2[curstate[7]]);

  result[8] = (unsigned char)(mul2[curstate[8]] ^ mul3[curstate[9]] ^ curstate[10] ^ curstate[11]);
  result[9] = (unsigned char)(curstate[8] ^ mul2[curstate[9]] ^ mul3[curstate[10]] ^ curstate[11]);
  result[10] = (unsigned char)(curstate[8] ^ curstate[9] ^ mul2[curstate[10]] ^ mul3[curstate[11]]);
  result[11] = (unsigned char)(mul3[curstate[8]] ^ curstate[9] ^ curstate[10] ^ mul2[curstate[11]]);

  result[12] = (unsigned char)(mul2[curstate[12]] ^ mul3[curstate[13]] ^ curstate[14] ^ curstate[15]);
  result[13] = (unsigned char)(curstate[12] ^ mul2[curstate[13]] ^ mul3[curstate[14]] ^ curstate[15]);
  result[14] = (unsigned char)(curstate[12] ^ curstate[13] ^ mul2[curstate[14]] ^ mul3[curstate[15]]);
  result[15] = (unsigned char)(mul3[curstate[12]] ^ curstate[13] ^ curstate[14] ^ mul2[curstate[15]]);

  //reassigning the correct values to the current state using the results from mixColumns
  for (int i = 0; i < 16; ++i) {
    curstate[i] = result[i];
  }
}

/* replacing each column by its value multiplied by a 4x4 matrix that represents
*  the inverse of mix columns */
void invMixColumns(unsigned char* curstate) {
  //stores the resulting multiplied matrix
  unsigned char result[16];
  /*hardcoding the matrix multiplication,
  * XOR bits is the equivalent the addition part of the dot products */
  result[0] = (unsigned char)(mule[curstate[0]] ^ mulb[curstate[1]] ^ muld[curstate[2]] ^ mul9[curstate[3]]);
  result[1] = (unsigned char)(mul9[curstate[0]] ^ mule[curstate[1]] ^ mulb[curstate[2]] ^ muld[curstate[3]]);
  result[2] = (unsigned char)(muld[curstate[0]] ^ mul9[curstate[1]] ^ mule[curstate[2]] ^ mulb[curstate[3]]);
  result[3] = (unsigned char)(mulb[curstate[0]] ^ muld[curstate[1]] ^ mul9[curstate[2]] ^ mule[curstate[3]]);

  result[4] = (unsigned char)(mule[curstate[4]] ^ mulb[curstate[5]] ^ muld[curstate[6]] ^ mul9[curstate[7]]);
  result[5] = (unsigned char)(mul9[curstate[4]] ^ mule[curstate[5]] ^ mulb[curstate[6]] ^ muld[curstate[7]]);
  result[6] = (unsigned char)(muld[curstate[4]] ^ mul9[curstate[5]] ^ mule[curstate[6]] ^ mulb[curstate[7]]);
  result[7] = (unsigned char)(mulb[curstate[4]] ^ muld[curstate[5]] ^ mul9[curstate[6]] ^ mule[curstate[7]]);

  result[8] = (unsigned char)(mule[curstate[8]] ^ mulb[curstate[9]] ^ muld[curstate[10]] ^ mul9[curstate[11]]);
  result[9] = (unsigned char)(mul9[curstate[8]] ^ mule[curstate[9]] ^ mulb[curstate[10]] ^ muld[curstate[11]]);
  result[10] = (unsigned char)(muld[curstate[8]] ^ mul9[curstate[9]] ^ mule[curstate[10]] ^ mulb[curstate[11]]);
  result[11] = (unsigned char)(mulb[curstate[8]] ^ muld[curstate[9]] ^ mul9[curstate[10]] ^ mule[curstate[11]]);

  result[12] = (unsigned char)(mule[curstate[12]] ^ mulb[curstate[13]] ^ muld[curstate[14]] ^ mul9[curstate[15]]);
  result[13] = (unsigned char)(mul9[curstate[12]] ^ mule[curstate[13]] ^ mulb[curstate[14]] ^ muld[curstate[15]]);
  result[14] = (unsigned char)(muld[curstate[12]] ^ mul9[curstate[13]] ^ mule[curstate[14]] ^ mulb[curstate[15]]);
  result[15] = (unsigned char)(mulb[curstate[12]] ^ muld[curstate[13]] ^ mul9[curstate[14]] ^ mule[curstate[15]]);

  //reassigning the correct values to the current state using the results from mixColumns
  for (int i = 0; i < 16; ++i) {
    curstate[i] = result[i];
  }
}

/* The round key is added to the state simply by using bitwise XOR with the
* round key and the current state.
* This function is also its own inverse. */
void addRoundKey(unsigned char* curstate, unsigned char* r_key, int rounds) {
  int looptimes = 16;
  if (rounds == 14) {
    looptimes = 32;
  }
  for (int i = 0; i < looptimes; ++i) {
    curstate[i] = curstate[i] ^ r_key[i];
  }
}

//compare bytes with sbox and replace with corresponding values
void subWord(unsigned char* four_bytes) {
  four_bytes[0] = sbox[four_bytes[0]];
  four_bytes[1] = sbox[four_bytes[1]];
  four_bytes[2] = sbox[four_bytes[2]];
  four_bytes[3] = sbox[four_bytes[3]];
}

/* algorithm for key expansion */
void expansionAlgo(unsigned char* four_bytes, unsigned char rcon_index) {
  //shift the bytes to the left by one byte
  //also known as rotWord()
  unsigned char tmp = four_bytes[0];
  four_bytes[0] = four_bytes[1];
  four_bytes[1] = four_bytes[2];
  four_bytes[2] = four_bytes[3];
  four_bytes[3] = tmp;

  //subWord
  subWord(four_bytes);

  //rcon -- raising 2 to the power of rcon_index - 1
  four_bytes[0] = four_bytes[0] ^ rcon[rcon_index];
}

void expandKey(unsigned char r_key[32], unsigned char algo_keys[256], int rounds) {

  int bytes_to_expand = 16;
  if (rounds == 10) {
    //first 128 bits is the original key
    for (int i = 0; i < 16; ++i) {
      algo_keys[i] = r_key[i];
    }
  }
  if (rounds == 14) {
    bytes_to_expand = 32;
    //first 256 bits is the original key
    for (int i = 0; i < 32; ++i) {
      algo_keys[i] = r_key[i];
    }
  }
  int bytes_added = 16;
  if (rounds == 14) {
    bytes_added = 32;
  }
  int byte_limit = 176;
  if (rounds == 14) {
    byte_limit = 256;
  }
  int rcon_index = 1;
  unsigned char tmp[4];
  while (bytes_added < byte_limit) {
    //read 4 bytes for the expansion algorithm
    for (int i = 0; i < 4; ++i) {
      tmp[i] = algo_keys[i + bytes_added - 4];
    }
    //only if bytes added is multiple of 16 but not multiple of 32
    if (rounds == 14) {
      if ((bytes_added % 16 == 0) && !(bytes_added % 32 == 0)) {
        subWord(tmp);
      }
    }
    //do expansion algo every 16 bytes
    if (bytes_added % bytes_to_expand == 0) {
      expansionAlgo(tmp, rcon_index);
      ++rcon_index;
    }
    for (unsigned char c = 0; c < 4; ++c) {
      algo_keys[bytes_added] = algo_keys[bytes_added-bytes_to_expand] ^ tmp[c];
      ++bytes_added;
    }
  }
}

//store expanded key
unsigned char e_key[224];

/* cycles through the encryption algorithm a given number
* of times depending on the keysize, if the keysize is 128 bits,
* the algorithm will run through 10 rounds; if the keysize is 256 bits,
* the algorithm will run through 14 rounds */
void encryptCycleRounds(unsigned char* curstate, unsigned char* r_key, int rounds) {
  //expand keys
  int expanded_key_len = 176;
  int times_bytes = 160;
  if (rounds == 14) {
    times_bytes = 224;
  }
  if (rounds == 14) {
    expanded_key_len = 256;
  }

  unsigned char exp_key[expanded_key_len];
  expandKey(r_key, exp_key, rounds);

  for (int i = 0; i < expanded_key_len; ++i) {
    e_key[i] = exp_key[i];
  }

  addRoundKey(curstate, r_key, rounds);
  int i = 0;
  for (i = 1; i <= rounds-1; ++i) {
    subBytes(curstate);
    shiftRows(curstate);
    mixColumns(curstate);
    addRoundKey(curstate, 16*i + exp_key, rounds);
  }
  //the final round is special as it does not include mixColumns
  subBytes(curstate);
  shiftRows(curstate);
  addRoundKey(curstate, exp_key + times_bytes, rounds);
}

/* cycles through the encryption algorithm a given number
* of times depending on the keysize, it is simply the encryption
* algorithm but using the inverse functions */
void decryptCycleRounds(unsigned char* curstate, unsigned char* r_key, int rounds) {
  //decrypt with expanded key
  int expanded_key_len = 176;
  if (rounds == 14) {
    expanded_key_len = 256;
  }
  unsigned char exp_key[expanded_key_len];
  expandKey(r_key, exp_key, rounds);
  for (int i = 0; i < expanded_key_len; ++i) {
    e_key[i] = exp_key[i];
  }
  int times_bytes = 160;
  if (rounds == 14) {
    times_bytes = 224;
  }
  //inverse of addRoundKey function is itself
  addRoundKey(curstate, e_key+times_bytes, rounds);
  int i = 0;
  for (i = rounds-1; i > 0; --i) {
    invShiftRows(curstate);
    invSubBytes(curstate);
    addRoundKey(curstate, e_key + 16*i, rounds);
    invMixColumns(curstate);
  }
  //again, the final round does not include mixColumns
  invShiftRows(curstate);
  invSubBytes(curstate);
  addRoundKey(curstate, exp_key, rounds);
}

//handles file input and starts program
int main(int argc, char *argv[]) {

  int rounds = 0;
  int keysize = 0;
  char* keyfile_name = NULL;
  char* inputfile_name = NULL;
  char* outputfile_name = NULL;
  char* mode = NULL;

  for (int i = 1; i < argc-1; i++) {
    if (strcmp(argv[i], "--keysize") == 0) {
      keysize = atoi(argv[i+1]);
    }
    if (strcmp(argv[i], "--keyfile") == 0) {
      keyfile_name = argv[i+1];
    }
    if (strcmp(argv[i], "--inputfile") == 0) {
      inputfile_name = argv[i+1];
    }
    if (strcmp(argv[i], "--outputfile") == 0) {
      outputfile_name = argv[i+1];
    }
    if (strcmp(argv[i], "--mode") == 0) {
      mode = argv[i+1];
    }
  }

  //using AES-128
  if(keysize == 128) {
    rounds = 10;
  }
  //using AES-256
  if (keysize == 256) {
    rounds = 14;
  }

  //read in bytes of input file
  FILE *input_fileptr;
  unsigned char *input_buffer;
  long input_filelen;

  //get input file in binary
  input_fileptr = fopen(inputfile_name, "rb");
  fseek(input_fileptr, 0, SEEK_END);
  input_filelen = ftell(input_fileptr);
  rewind(input_fileptr);

  //allocate memory for the file
  input_buffer = (unsigned char *)malloc((input_filelen+1)*sizeof(char));
  fread(input_buffer, input_filelen, 1, input_fileptr);
  fclose(input_fileptr);

  //read in bytes of key file
  FILE *key_fileptr;
  unsigned char *key_buffer;
  long key_filelen;

  //get key file in binary
  key_fileptr = fopen(keyfile_name, "rb");
  fseek(key_fileptr, 0, SEEK_END);
  key_filelen = ftell(key_fileptr);
  rewind(key_fileptr);

  //allocate memory for the file
  key_buffer = (unsigned char *)malloc((key_filelen+1)*sizeof(char));
  fread(key_buffer, key_filelen, 1, key_fileptr);
  fclose(key_fileptr);

  unsigned char* curstate = input_buffer;
  unsigned char* r_key = key_buffer;

  //padding with state with 0s if number of bytes is NOT a multiple of 16
  int curstate_size = sizeof(curstate);

  int new_size = curstate_size * 2;
  int padded = 0;
  if (new_size % 16 != 0) {
    new_size = ((new_size/16+1) * 16)/2;
    padded = 1;
  }

  unsigned char padded_state[new_size];
  for (int i = 0; i < new_size; ++i) {
    if (i >= curstate_size) {
      padded_state[i] = 0;
    } else {
      padded_state[i] = curstate[i];
    }
  }

  /*if state size is larger than 16, grab the first 16 bytes to encrypt/decrypt,
  * then grab next bytes */

  //saves all bytes that are being encrypted or decrypted
  unsigned char tmp[new_size];
  if (new_size > 16 || curstate_size*2 > 16) {
    if (padded == 1) {
      if (new_size > 16) {
        int times = (new_size)/16;
        if (strcmp(mode, "encrypt") == 0) {
          for (int i = 0; i < times; ++i) {
            encryptCycleRounds(padded_state + 16*i, r_key, rounds);
            //copy over encrypted state 16 bytes at a time
            memcpy(tmp + 16*i, padded_state + 16*i, 16);
          }
        }
        if (strcmp(mode, "decrypt") == 0) {
          for (int i = 0; i < times; ++i) {
            decryptCycleRounds(padded_state + 16*i, r_key, rounds);
            //copy over 16 bytes at a time
            for (int k = 0; k < 16; ++k) {
              //copy over decrypted state 16 bytes at a time
              memcpy(tmp + 16*i, padded_state + 16*i, 16);
            }
          }
        }
      }
      //copy over newly encrypted or decrypted state to back padded_state
      for (int i = 0; i < new_size; ++i) {
        padded_state[i] = tmp[i];
      }
    } else {
      if (curstate_size*2 > 16) {
        int times = (new_size)/16;
        if (strcmp(mode, "encrypt") == 0) {
          for (int i = 0; i < times; ++i) {
            encryptCycleRounds(curstate + 16*i, r_key, rounds);
            //copy over encrypted state 16 bytes at a time
            memcpy(tmp + 16*i, padded_state + 16*i, 16);
          }
        }
        if (strcmp(mode, "decrypt") == 0) {
          for (int i = 0; i < times; ++i) {
            decryptCycleRounds(curstate + 16*i, r_key, rounds);
            //copy over decrypted state 16 bytes at a time
            memcpy(tmp + 16*i, padded_state + 16*i, 16);
          }
        }
      }
      //copy over newly encrypted or decrypted state to back curstate
      for (int i = 0; i < new_size; ++i) {
        curstate[i] = tmp[i];
      }
    }
  } else {
    //using encryption
    if (strcmp(mode, "encrypt") == 0) {
      if (padded == 1) {
        encryptCycleRounds(padded_state, r_key, rounds);
      } else {
        encryptCycleRounds(curstate, r_key, rounds);
      }
    }
    //using decryption
    if (strcmp(mode, "decrypt") == 0) {
      decryptCycleRounds(curstate, r_key, rounds);
    }
  }


  //write bytes to output file
  FILE *write_ptr;

  //write to filename specified by output
  write_ptr = fopen(outputfile_name,"wb");  // w for write, b for binary

  fwrite(curstate,sizeof(curstate)*2,1,write_ptr); // write 10 bytes from our buffer

  return 0;
}
